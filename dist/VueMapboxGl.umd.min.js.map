{"version":3,"file":"VueMapboxGl.umd.min.js","sources":["../src/utils/uniq-id.js","../src/utils/bind-events.js","../src/components/MapboxLayer.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/mixins/provide-inject-map.js","../src/components/MapboxGeocoder.vue","../node_modules/regenerator-runtime/runtime.js","../src/utils/bind-props.js","../src/components/MapboxMap.vue","../src/components/MapboxGeolocateControl.vue","../src/index.js"],"sourcesContent":["/**\n * Get a prefixed or not uniq id\n * @param  {String} prefix The prefix to add to the generated id\n * @return {String}        A (prefixed) uniq id\n */\nexport default function uniqId(prefix = '') {\n  const uniq = new Date().getTime() + Math.floor(Math.random() * 10000 + 1);\n  return prefix ? prefix + uniq.toString(16) : uniq.toString(16);\n}\n","/**\n * Map a mapbox element's events to the given vue element\n *\n * @param  {Vue}    vueElement    The Vue component in question\n * @param  {Mixed}  mapboxElement The Mapbox element bound to the component\n * @param  {Array}  events        The events to map\n * @param  {String} layerId       The layer on which the events are delegated\n * @return {Array}                The list of event/handler pair bounded\n */\nexport function bindEvents(vueElement, mapboxElement, events = [], layerId = null) {\n  const { $listeners: vueEvents } = vueElement;\n  // eslint-disable-next-line no-param-reassign\n  vueElement.$$events = Object.keys(vueEvents).reduce(($$events, vueEvent) => {\n    const originalEvent = vueEvent.replace(/^mb-/, '');\n    if (!events.includes(originalEvent)) {\n      return $$events;\n    }\n\n    const handler = (...payload) => {\n      vueElement.$emit(vueEvent, ...payload);\n    };\n\n    // If layerId is not null, all events must be\n    // delegated from the map to the given layerId\n    if (layerId) {\n      mapboxElement.on(originalEvent, layerId, handler);\n    } else {\n      mapboxElement.on(originalEvent, handler);\n    }\n\n    $$events.push([originalEvent, handler]);\n\n    return $$events;\n  }, []);\n}\n\n/**\n * Unbind events from the map element\n *\n * @param  {Mixed} mapboxElement The Mapbox element which needs unbinding\n * @param  {Array}  handlers     The list of event/handler pair to unbind\n * @param  {String} layerId      The layer on which the events where delegated\n * @return {void}\n */\nexport function unbindEvents(vueElement, mapboxElement, layerId = null) {\n  vueElement.$$events.forEach(([event, handler]) => {\n    // If layerId is not null, all events must be\n    // delegated from the map to the given layerId\n    if (layerId) {\n      mapboxElement.off(event, layerId, handler);\n    } else {\n      mapboxElement.off(event, handler);\n    }\n  });\n}\n","<template>\n  <div :id=\"id\" />\n</template>\n\n<script>\n  import { bindEvents, unbindEvents } from '../utils/bind-events';\n  import { injectMap } from '../mixins/provide-inject-map';\n\n  /**\n   * All Map events which will be mapped/bounded to the component\n   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#on\n   * @type {Array}\n   */\n  const events = [\n    'mousedown',\n    'mouseup',\n    'click',\n    'dblclick',\n    'mousemove',\n    'mouseenter',\n    'mouseleave',\n    'mouseover',\n    'mouseout',\n    'contextmenu',\n    'touchstart',\n    'touchend',\n    'touchcancel',\n  ];\n\n  export default {\n    name: 'MapboxLayer',\n    mixins: [ injectMap() ],\n    props: {\n      /**\n       * Id of the layer\n       * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer\n       * @type {String}\n       */\n      id: {\n        type: String,\n        required: true,\n      },\n      /**\n       * Options for the layer\n       * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer\n       * @see  https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers\n       * @type {Object}\n       */\n      options: {\n        type: Object,\n        default: () => {},\n      },\n      /**\n       * The ID of an existing layer to insert the new layer before.\n       * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer\n       * @type {String}\n       */\n      beforeId: {\n        type: String,\n        default: undefined,\n      },\n    },\n    mounted() {\n      // Make sure to remove any existing layer and/or source to avoid conflicts\n      if (this.layerExists()) {\n        this.map.removeLayer(this.id);\n      }\n\n      if (this.sourceExists()) {\n        this.map.removeSource(this.id);\n      }\n\n      // Bind events\n      bindEvents(this, this.map, events, this.id);\n\n      if (this.options.paint === null || this.options.paint === undefined) {\n        delete this.options.paint;\n      }\n\n      if (this.options.layout === null || this.options.layout === undefined) {\n        delete this.options.layout;\n      }\n\n      this.map.addLayer({ ...this.options, id: this.id }, this.beforeId);\n    },\n    destroyed() {\n      if (this.layerExists()) {\n        unbindEvents(this, this.map, this.id);\n        this.map.removeLayer(this.id);\n      }\n\n      if (this.sourceExists()) {\n        this.map.removeSource(this.id);\n      }\n    },\n    methods: {\n      /**\n       * Test if the component's layer exists\n       * @return {Boolean}\n       */\n      layerExists() {\n        return typeof this.map.getLayer(this.id) !== 'undefined';\n      },\n      /**\n       * Test if a source with the layer's ID exists\n       * @return {Boolean}\n       */\n      sourceExists() {\n        return typeof this.map.getSource(this.id) !== 'undefined';\n      },\n    },\n  };\n</script>\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","/**\n * Provide to children components a $map function to retrieve a map object\n *\n * @return {Object}\n */\nexport const provideMap = () => ({\n  data() {\n    return {\n      map: null,\n    };\n  },\n  provide() {\n    return {\n      $map: () => this.map,\n    };\n  },\n});\n\n/**\n * Inject from parent component a $map function to retrieve a map object\n *\n * @return {Object}\n */\nexport const injectMap = () => ({\n  inject: {\n    $map: { default: null },\n  },\n  computed: {\n    map() {\n      return typeof this.$map === 'function' ? this.$map() : null;\n    },\n  },\n});\n","<template>\n  <div />\n</template>\n\n<script>\n  import mapboxgl from 'mapbox-gl';\n  import MapboxGeocoder from '@mapbox/mapbox-gl-geocoder';\n  import { injectMap } from '../mixins/provide-inject-map';\n  import { bindEvents, unbindEvents } from '../utils/bind-events';\n\n  if (!mapboxgl) {\n    throw new Error('mapboxgl is not installed.');\n  }\n\n  if (!MapboxGeocoder) {\n    throw new Error('MapboxGeocoder is not installed.');\n  }\n\n  /**\n   ** Component's props definition, we need to declare it outside the component\n   * to be able to test the default values and the types.\n   * @see https://github.com/mapbox/mapbox-gl-geocoder/blob/master/API.md#parameters\n   * @type {object}\n   */\n  const props = {\n    accessToken: {\n      type: String,\n      default: 'no-token',\n    },\n    zoom: {\n      type: Number,\n      default: () => 16,\n    },\n    flyTo: {\n      type: [ Boolean, Object ],\n      default: () => true,\n    },\n    placeholder: {\n      type: String,\n      default: () => 'Search',\n    },\n    proximity: {\n      type: Object,\n      default: () => {},\n    },\n    trackProximity: {\n      type: Boolean,\n      default: () => true,\n    },\n    collapsed: {\n      type: Boolean,\n      default: () => false,\n    },\n    clearAndBlurOnEsc: {\n      type: Boolean,\n      default: () => false,\n    },\n    clearOnBlur: {\n      type: Boolean,\n      default: () => false,\n    },\n    bbox: {\n      type: Array,\n      default: () => [],\n    },\n    countries: {\n      type: String,\n      default: () => '',\n    },\n    types: {\n      type: String,\n      default: () => '',\n    },\n    minLength: {\n      type: Number,\n      default: () => 2,\n    },\n    limit: {\n      type: Number,\n      default: () => 5,\n    },\n    language: {\n      type: String,\n    },\n    filter: {\n      type: Function,\n    },\n    localGeocoder: {\n      type: Function,\n    },\n    reverseMode: {\n      type: String,\n      default: () => 'distance',\n    },\n    reverseGeocode: {\n      type: Boolean,\n      default: () => false,\n    },\n    enableEventLogging: {\n      type: Boolean,\n      default: () => false,\n    },\n    marker: {\n      type: Boolean,\n      default: () => true,\n    },\n    render: {\n      type: Function,\n    },\n    getItemValue: {\n      type: Function,\n      default: (item) => item.place_name,\n    },\n    mode: {\n      type: String,\n      default: () => 'mapbox.places',\n    },\n    localGeocoderOnly: {\n      type: Boolean,\n      default: () => false,\n    },\n  };\n\n  /**\n   * All Map events which will be mapped/bounded to the component\n   * @see  https://github.com/mapbox/mapbox-gl-geocoder/blob/master/API.md#on\n   * @type {Array}\n   */\n  const events = [ 'loading', 'results', 'result', 'error' ];\n\n  export default {\n    name: 'MapboxGeocoder',\n    mixins: [ injectMap() ],\n    props,\n    mounted() {\n      const { accessToken, ...$props } = this.$props;\n\n      // Delete the `reverseMode` property if we are not reverse geocoding as it is not supported by\n      // the Mapbox SDK.\n      //\n      // The `reverseMode` option can not be supported yet as it is conditionned by the search\n      // query format following a specific regex:\n      //\n      // ```js\n      //  /(-?\\d+\\.?\\d*)[, ]+(-?\\d+\\.?\\d*)[ ]*$/.test(searchInput)\n      // ```\n      //\n      // @todo use the same regex as the mapbox-gl-geocoder lib or open an issue\n      //\n      // @see https://github.com/mapbox/mapbox-sdk-js/blob/main/services/geocoding.js (92-104)\n      // @see https://github.com/mapbox/mapbox-sdk-js/blob/main/services/geocoding.js (161-172)\n      // @see https://github.com/mapbox/mapbox-gl-geocoder/blob/master/lib/index.js (437-458)\n      // eslint-disable-next-line no-constant-condition\n      if (!$props.reverseGeocode || true) {\n        delete $props.reverseMode;\n      }\n\n      this.control = new MapboxGeocoder({\n        accessToken: mapboxgl.accessToken || accessToken,\n        mapboxgl,\n        ...$props,\n      });\n\n      // Bind events\n      bindEvents(this, this.control, events);\n      this.$emit('mb-created', this.control);\n\n      this.control.addTo(this.map || this.$el);\n    },\n    destroyed() {\n      unbindEvents(this, this.control);\n      if (this.map) {\n        this.map.removeControl(this.control);\n      }\n    },\n  };\n</script>\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * Capitalize the first letter of a string\n *\n * @param  {String} string The string to capitalize\n * @return {String}        The capitalized string\n */\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n/**\n * Automatically set a mapbox element's props when the vue element props changes\n *\n * @param  {Vue}    vueElement    The Vue component in question\n * @param  {Mixed}  mapboxElement The Mapbox element bound to the component\n * @param  {Object} props         The component's props definition object\n * @return {void}\n */\nexport default function bindProps(vueElement, mapboxElement, props) {\n  Object.keys(vueElement.$props)\n    .filter((prop) => prop !== undefined)\n    .forEach((prop) => {\n      const setMethodName = prop === 'mapStyle' ? 'setStyle' : `set${capitalizeFirstLetter(prop)}`;\n\n      const methodExists = typeof mapboxElement[setMethodName] === 'function';\n      const propNeedsBinding = 'bind' in props[prop] ? props[prop].bind : true;\n\n      // Do nothin if `setMethodName` is not a function of `mapBoxElement`\n      // or if the props is not to be bounded\n      if (!methodExists || !propNeedsBinding) {\n        return;\n      }\n\n      // Set deep option to true if prop type is or can be Object\n      const { type } = props[prop];\n      const options = {\n        deep: type === Object || (Array.isArray(type) && type.includes(Object)),\n      };\n\n      vueElement.$watch(\n        prop,\n        (newValue) => {\n          mapboxElement[setMethodName](newValue);\n        },\n        options\n      );\n    });\n}\n","<template>\n  <div>\n    <div v-if=\"isLoaded\">\n      <slot />\n    </div>\n    <div v-else>\n      <slot name=\"loader\" />\n    </div>\n  </div>\n</template>\n\n<script>\n  import mapboxgl, { LngLatBounds, LngLat } from 'mapbox-gl';\n  import bindProps from '../utils/bind-props';\n  import { bindEvents, unbindEvents } from '../utils/bind-events';\n  import { provideMap } from '../mixins/provide-inject-map';\n\n  if (!mapboxgl) {\n    throw new Error('mapboxgl is not installed.');\n  }\n\n  /**\n   * Component's props definition, we need to declare it outside the component\n   * to be able to test the default values and the types.\n   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map\n   * @type {Object}\n   */\n  const props = {\n    accessToken: {\n      type: String,\n      default: 'no-token',\n    },\n    container: {\n      type: [ Object, String ],\n      default: undefined,\n    },\n    minZoom: {\n      type: Number,\n      default: 0,\n    },\n    maxZoom: {\n      type: Number,\n      default: 22,\n    },\n    minPitch: {\n      type: Number,\n      default: 0,\n    },\n    maxPitch: {\n      type: Number,\n      default: 60,\n    },\n    mapStyle: {\n      type: [ Object, String ],\n      required: true,\n    },\n    hash: {\n      type: Boolean,\n      default: false,\n    },\n    interactive: {\n      type: Boolean,\n      default: true,\n    },\n    bearingSnap: {\n      type: Number,\n      default: 7,\n    },\n    pitchWithRotate: {\n      type: Boolean,\n      default: true,\n    },\n    clickTolerance: {\n      type: Number,\n      default: 3,\n    },\n    attributionControl: {\n      type: Boolean,\n      default: true,\n    },\n    customAttribution: {\n      type: [ String, Array ],\n      default: null,\n    },\n    logoPosition: {\n      type: String,\n      default: 'bottom-left',\n    },\n    failIfMajorPerformanceCaveat: {\n      type: Boolean,\n      default: false,\n    },\n    preserveDrawingBuffer: {\n      type: Boolean,\n      default: false,\n    },\n    antialias: {\n      type: Boolean,\n      default: false,\n    },\n    refreshExpiredTiles: {\n      type: Boolean,\n      default: true,\n    },\n    maxBounds: {\n      type: [ LngLatBounds, Array ],\n      default: undefined,\n    },\n    scrollZoom: {\n      type: [ Boolean, Object ],\n      default: true,\n    },\n    boxZoom: {\n      type: Boolean,\n      default: true,\n    },\n    dragRotate: {\n      type: Boolean,\n      default: true,\n    },\n    dragPan: {\n      type: [ Boolean, Object ],\n      default: true,\n    },\n    keyboard: {\n      type: Boolean,\n      default: true,\n    },\n    doubleClickZoom: {\n      type: Boolean,\n      default: true,\n    },\n    touchZoomRotate: {\n      type: [ Boolean, Object ],\n      default: true,\n    },\n    trackResize: {\n      type: Boolean,\n      default: true,\n    },\n    center: {\n      type: [ LngLat, Array, Object ],\n      default: () => [ 0, 0 ],\n    },\n    zoom: {\n      type: Number,\n      default: 0,\n    },\n    bearing: {\n      type: Number,\n      default: 0,\n    },\n    pitch: {\n      type: Number,\n      default: 0,\n    },\n    bounds: {\n      type: [ LngLatBounds, Array ],\n      default: undefined,\n    },\n    fitBoundsOptions: {\n      type: Object,\n      default: null,\n    },\n    renderWorldCopies: {\n      type: Boolean,\n      default: true,\n    },\n    maxTileCacheSize: {\n      type: Number,\n      default: null,\n    },\n    localIdeographFontFamily: {\n      type: String,\n      default: 'sans-serif',\n    },\n    transformRequest: {\n      type: Function,\n      default: null,\n    },\n    collectResourceTiming: {\n      type: Boolean,\n      default: false,\n    },\n    fadeDuration: {\n      type: Number,\n      default: 300,\n    },\n    crossSourceCollisions: {\n      type: Boolean,\n      default: true,\n    },\n  };\n\n  /**\n   * All Map events which will be mapped/bounded to the component\n   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map.event:resize\n   * @type {Array}\n   */\n  const events = [\n    'resize',\n    'remove',\n    'mousedown',\n    'mouseup',\n    'mouseover',\n    'mousemove',\n    'click',\n    'dblclick',\n    'mouseenter',\n    'mouseleave',\n    'mouseout',\n    'contextmenu',\n    'wheel',\n    'touchstart',\n    'touchend',\n    'touchmove',\n    'touchcancel',\n    'movestart',\n    'move',\n    'moveend',\n    'dragstart',\n    'drag',\n    'dragend',\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'rotatestart',\n    'rotate',\n    'rotateend',\n    'pitchstart',\n    'pitch',\n    'pitchend',\n    'boxzoomstart',\n    'boxzoomend',\n    'boxzoomcancel',\n    'webglcontextlost',\n    'webglcontextrestored',\n    'load',\n    'render',\n    'idle',\n    'error',\n    'data',\n    'styledata',\n    'sourcedata',\n    'dataloading',\n    'styledataloading',\n    'sourcedataloading',\n    'styleimagemissing',\n  ];\n\n  export default {\n    name: 'MapboxMap',\n    mixins: [ provideMap() ],\n    props,\n    data() {\n      return {\n        isLoaded: false,\n      };\n    },\n    computed: {\n      options() {\n        const { accessToken, mapStyle: style, ...options } = this.$props;\n\n        // Use current component's element if container is not set\n        if (!options.container && this.$el) {\n          options.container = this.$el;\n        }\n\n        return { style, ...options };\n      },\n    },\n    mounted() {\n      mapboxgl.accessToken = this.accessToken;\n      this.map = new mapboxgl.Map(this.options);\n      this.map.on('load', () => {\n        this.isLoaded = true;\n      });\n\n      // Bind props and events\n      bindProps(this, this.map, props);\n      bindEvents(this, this.map, events);\n      this.$emit('mb-created', this.map);\n\n      // Mapbox has some resize issues\n      // Create an observer on this object\n      // Call resize on the map when we change szie\n      const observer = new ResizeObserver(this.resizeHandler);\n      observer.observe(this.options.container);\n      this.resizeObserver = observer;\n    },\n    destroyed() {\n      unbindEvents(this, this.map);\n      this.resizeObserver.disconnect();\n      this.map.remove();\n    },\n    methods: {\n      /**\n       * Handler for any change of the map's size\n       *\n       * @return {void}\n       */\n      resizeHandler() {\n        if (this.map) {\n          this.map.resize();\n        }\n      },\n    },\n  };\n</script>\n","<template>\n  <div />\n</template>\n\n<script>\n  import mapboxgl from 'mapbox-gl';\n  import { injectMap } from '../mixins/provide-inject-map';\n  import bindProps from '../utils/bind-props';\n  import { bindEvents, unbindEvents } from '../utils/bind-events';\n\n  if (!mapboxgl) {\n    throw new Error('mapboxgl is not installed.');\n  }\n\n  /**\n   * Component's props definition, we need to declare it outside the component\n   * to be able to test the default values and the types.\n   * @see https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol\n   * @type {Object}\n   */\n  const props = {\n    positionOptions: {\n      type: Object,\n      default: () => ({ enableHighAccuracy: false, timeout: 6000 }),\n    },\n    fitBoundsOptions: {\n      type: Object,\n      default: () => ({ maxZoom: 15 }),\n    },\n    trackUserLocation: {\n      type: Boolean,\n      default: false,\n    },\n    showAccuracyCircle: {\n      type: Boolean,\n      default: true,\n    },\n    showUserLocation: {\n      type: Boolean,\n      default: true,\n    },\n    position: {\n      type: String,\n      default: 'top-right',\n      bind: false,\n    },\n  };\n\n  /**\n   * All geolocationControl events which will be mapped/bounded to the component\n   * @see https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol.event:trackuserlocationend\n   * @type {Array}\n   */\n  const events = [\n    'trackuserlocationend',\n    'error',\n    'geolocate',\n    'outofmaxbounds',\n    'trackuserlocationstart',\n  ];\n\n  export default {\n    name: 'MapboxGeolocateControl',\n    mixins: [ injectMap() ],\n    props,\n    mounted() {\n      this.control = new mapboxgl.GeolocateControl(this.$props);\n\n      // Bind props and events\n      bindProps(this, this.control, props);\n      bindEvents(this, this.control, events);\n\n      // Add GeolocationControl to the map\n      this.map.addControl(this.control, this.position);\n    },\n    destroyed() {\n      if (this.control) {\n        unbindEvents(this, this.control, events);\n        this.map.removeControl(this.control);\n      }\n    },\n  };\n</script>\n","import * as components from './components';\n\n/**\n * Install all components\n *\n * @param  {Vue}  Vue The Vue object\n * @return {void}\n */\nexport function install(Vue) {\n  Object.keys(components).forEach((name) => {\n    Vue.component(name, components[name]);\n  });\n}\n\n// Export each components separately\nexport * from './components';\n\n// Export the install function as default\nexport default install;\n"],"names":["uniqId","prefix","uniq","Date","getTime","Math","floor","random","toString","bindEvents","vueElement","mapboxElement","events","layerId","vueEvents","$listeners","$$events","Object","keys","reduce","vueEvent","originalEvent","replace","includes","handler","payload","$emit","on","push","unbindEvents","forEach","event","off","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","this","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","inject","$map","default","computed","map","runtime","exports","undefined","Op","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","bindProps","props","$props","filter","prop","string","setMethodName","toUpperCase","methodExists","propNeedsBinding","bind","deep","Array","isArray","$watch","newValue","data","provide","_this","install","Vue","components","component"],"mappings":"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"}